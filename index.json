{"categories":[],"pages":[],"posts":[{"link":"/posts/cpp-range-format/","text":"With recent release of GCC 15.2, C++23 range formatting has gained full support of all mainstream compilers. This means you can now format containers like std::vector and std::map directly with std::format, eliminating the need for manual loops. Though there are some simple examples on the Internet, I have not found an introduction comparable to those of std::format. This post aims to be a relatively comprehensive guide.\nBackground std::format std::format was introduced in C++20 to provide a modern way to format strings.\nCPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { /* Outputs `Hello, world!` */ std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\u0026#34;, \u0026#34;world\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } Click to expand and view more You can specialize std::formatter to support custom types.\nExample for std::formatter specialization CPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; struct Point { int x, y; }; template\u0026lt;\u0026gt; struct std::formatter\u0026lt;Point\u0026gt; { constexpr auto parse(std::format_parse_context\u0026amp; ctx) { return ctx.begin(); } auto format(const Point\u0026amp; p, std::format_context\u0026amp; ctx) const { return std::format_to(ctx.out(), \u0026#34;({}, {})\u0026#34;, p.x, p.y); } }; int main() { Point p{1, 2}; /* Outputs `(1, 2)` */ std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{}\u0026#34;, p) \u0026lt;\u0026lt; std::endl; return 0; } Click to expand and view more Range Formatting C++23 introduces range formatting, which allows you to easily format containers like vector and map. With C++23, we can use std::print for output.\nCPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;version\u0026gt; int main() { const std::set\u0026lt;int\u0026gt; deadbeef{0xDE, 0xAD, 0xBE, 0xEF}; /* Before C++23 */ bool first = true; std::cout \u0026lt;\u0026lt; \u0026#34;{\u0026#34;; for (const auto\u0026amp; x: deadbeef) { if (!first) std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; else first = false; std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{:#x}\u0026#34;, x); } std::cout \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; std::endl; /* After C++23 */ #ifdef __cpp_lib_format_ranges /* Outputs `{0xad, 0xbe, 0xde, 0xef}` */ std::println(\u0026#34;{::#x}\u0026#34;, deadbeef); #endif return 0; } Click to expand and view more Format specification after the second : (#x, hex with prefix) will be applied to each element.\nRange Formatting with User-defined Element Type It is not hard to combine range formatting and custom type formatting.\nCPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;vector\u0026gt; struct Point { int x, y; }; template\u0026lt;\u0026gt; struct std::formatter\u0026lt;Point\u0026gt; { constexpr auto parse(std::format_parse_context\u0026amp; ctx) { return ctx.begin(); } template\u0026lt;typename Out\u0026gt; auto format(const Point\u0026amp; p, std::basic_format_context\u0026lt;Out, char\u0026gt;\u0026amp; ctx) const { return std::format_to(ctx.out(), \u0026#34;({}, {})\u0026#34;, p.x, p.y); } }; int main() { std::vector\u0026lt;Point\u0026gt; ps{{1, 2}, {3, 4}, {5, 6}}; /* Outputs `[(1, 2), (3, 4), (5, 6)]` */ std::println(\u0026#34;{}\u0026#34;, ps); return 0; } Click to expand and view more A Small Challenge Why is template\u0026lt;typename Out\u0026gt; needed? If you replace basic_format_context\u0026lt;Out, char\u0026gt; with format_context, the compilation will fail with the error std::formatter must be specialized for each type being formatted.\nTL;DR: formattable\u0026lt;Point\u0026gt; requires format function to accept a different context than std::format_context. Using template\u0026lt;typename Out\u0026gt; makes it work with both contexts.\nDetails Here is the implementation from libstdc++.\nCPP Collapse Copy template\u0026lt;typename _Tp, __format::__char _CharT = char\u0026gt; requires same_as\u0026lt;remove_cvref_t\u0026lt;_Tp\u0026gt;, _Tp\u0026gt; \u0026amp;\u0026amp; formattable\u0026lt;_Tp, _CharT\u0026gt; class range_formatter; template\u0026lt;ranges::input_range _Rg, __format::__char _CharT\u0026gt; requires (format_kind\u0026lt;_Rg\u0026gt; != range_format::disabled) \u0026amp;\u0026amp; formattable\u0026lt;ranges::range_reference_t\u0026lt;_Rg\u0026gt;, _CharT\u0026gt; struct formatter\u0026lt;_Rg, _CharT\u0026gt; { private: using _Vt = remove_cvref_t\u0026lt;ranges::range_reference_t\u0026lt;_Rg\u0026gt;\u0026gt;; using _Formatter_under = range_formatter\u0026lt;_Vt, _CharT\u0026gt;; _Formatter_under _M_under; public: /* ... */ }; Click to expand and view more formatter\u0026lt;range\u0026gt; simply delegates to underlying range_formatter. Previous error message indicates the substitution is failed. Let\u0026rsquo;s try to instantiate a range_formatter\u0026lt;Point\u0026gt; and see what happens. The compiler now complains __formattable_with\u0026lt;Point, basic_format_context\u0026lt;_Iter_for_t\u0026lt;char\u0026gt;, char\u0026gt; \u0026gt; is not satisfied, which is required by formattable\u0026lt;Point\u0026gt;. Note that anything starts with _ is implementation specific. However, format_context is an alias for basic_format_context\u0026lt;_Sink_iter\u0026lt;char\u0026gt;, char\u0026gt;, which does not meet the condition.\nTakeaway: For compatibility, template your format function.\nRange Formatting with User-defined Range Type If our class satisfies the input_range concept, range formatting should be available. The following example mimics Python\u0026rsquo;s range . (For simplicity, only part of the code is shown.)\nCPP Collapse Copy class xrange{ public: xrange(int _start, int _stop, int _step = 1); explicit xrange(int _end); class Iterator { public: using difference_type = std::ptrdiff_t; using value_type = int; Iterator\u0026amp; operator ++(); Iterator operator ++(int); value_type operator *() const; }; class Sentinel { public: friend bool operator ==(const Iterator\u0026amp; it, const Sentinel\u0026amp; s); }; Iterator begin() const; Sentinel end() const; }; int main() { int n = 3; /* Outputs `xrange(3) = [0, 1, 2]` */ std::println(\u0026#34;xrange({}) = {}\u0026#34;, n, xrange(n)); return 0; } Click to expand and view more Full code CPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;stdexcept\u0026gt; class xrange{ private: int m_start, m_stop, m_step; public: xrange(int _start, int _stop, int _step = 1) : m_start(_start), m_stop(_stop), m_step(_step) { if (m_step == 0) throw std::runtime_error(\u0026#34;step must not be zero\u0026#34;); } explicit xrange(int _end) : m_start(0), m_stop(_end), m_step(1) {} class Iterator; class Sentinel; Iterator begin() const { return Iterator{m_start, m_step}; } Sentinel end() const { return Sentinel{m_stop}; } class Iterator { private: int m_value, m_step; friend Sentinel; public: using difference_type = std::ptrdiff_t; using value_type = int; Iterator(int _value, int _step) : m_value(_value), m_step(_step) {} Iterator() = default; Iterator\u0026amp; operator ++() { m_value += m_step; return *this; } Iterator operator ++(int) { auto tmp = *this; ++*this; return tmp; } value_type operator *() const { return m_value; } }; class Sentinel { private: int m_end; public: explicit Sentinel(int _end) : m_end(_end) {} Sentinel() = default; friend bool operator ==(const Iterator\u0026amp; it, const Sentinel\u0026amp; s) { return (it.m_step \u0026gt;= 0 \u0026amp;\u0026amp; it.m_value \u0026gt;= s.m_end) || (it.m_step \u0026lt; 0 \u0026amp;\u0026amp; it.m_value \u0026lt;= s.m_end); } }; }; int main() { int n = 3; /* Outputs `xrange(3) = [0, 1, 2]` */ std::println(\u0026#34;xrange({}) = {}\u0026#34;, n, xrange(n)); return 0; } Click to expand and view more Range Formatting Customization range_formatter has three member functions that can be used to customize formatting.\nCPP Collapse Copy constexpr void set_separator( std::basic_string_view\u0026lt;CharT\u0026gt; sep ) noexcept; constexpr void set_brackets( std::basic_string_view\u0026lt;CharT\u0026gt; opening, std::basic_string_view\u0026lt;CharT\u0026gt; closing ) noexcept; constexpr std::formatter\u0026lt;T, CharT\u0026gt;\u0026amp; underlying() noexcept; /* and const variant */ Click to expand and view more In the following example, we assume that vector of vectors is a matrix and should be formatted differently. (Do NOT specialize std::formatter for standard library types in any serious project.)\nCPP Collapse Copy #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;vector\u0026gt; template\u0026lt;typename T\u0026gt; requires std::formattable\u0026lt;T, char\u0026gt; struct std::formatter\u0026lt;std::vector\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;\u0026gt; : std::range_formatter\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { constexpr formatter() noexcept { this-\u0026gt;set_separator(\u0026#34;\\n \u0026#34;); this-\u0026gt;underlying().set_separator(\u0026#34; \u0026#34;); this-\u0026gt;underlying().set_brackets(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } }; int main() { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; mat{{1, 2}, {3, 4}}; /* Outputs * ``` * [1 2 * 3 4] * ``` * instead of `[[1, 2], [3, 4]]` */ std::println(\u0026#34;{}\u0026#34;, mat); return 0; } Click to expand and view more Conclusion C++23 range formatting is a powerful complement to std::format that significantly reduces boilerplate when working with containers. Takeaways:\nAlways template your format function for compatibility. If your type satisfies input_range, you get range formatting automatically. No std::formatter specialization needed. Use range_formatter::set_separator(), set_brackets(), and underlying() to customize output for specific use cases. While you might be tempted to specialize formatters for container instantiations like vector\u0026lt;MyType\u0026gt; due to the unfriendly error message, a proper formatter\u0026lt;MyType\u0026gt; solves the problem more elegantly.\nBesides, the improved error messages from C++20 concepts (compared to SFINAE) make debugging much easier.\n","title":"A Practical Guide to C++23 Range Formatting"}],"tags":[{"link":"/tags/c++/","name":"C++","slug":"C++"},{"link":"/tags/programming/","name":"Programming","slug":"Programming"}]}