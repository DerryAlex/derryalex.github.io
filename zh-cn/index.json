{"categories":[],"pages":[],"posts":[{"link":"/zh-cn/posts/cpp-range-format/","text":"随着近期 GCC 15.2 的发布，C++23 的 range formatting 已在所有主流编译器上获得支持。这意味着你现在可以直接使用 std::format 来格式化像 std::vector 和 std::map 这样的容器，无需手动编写循环。尽管网上有一些简单的例子，但我还没有找到能与 std::format 指南相媲美的介绍。本文旨在提供一个相对全面的指南。\n注意 本文中文版由英文版用 LLM 翻译而来，并人工作了少许润色。\n背景 std::format C++20 中引入了 std::format，这提供了一种现代化的格式化方法。\nCPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { /* 输出 `Hello, world!` */ std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\u0026#34;, \u0026#34;world\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } 点击展开查看更多 可以通过特化 std::formatter 来支持自定义类型。\nstd::formatter 特化示例 CPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; struct Point { int x, y; }; template\u0026lt;\u0026gt; struct std::formatter\u0026lt;Point\u0026gt; { constexpr auto parse(std::format_parse_context\u0026amp; ctx) { return ctx.begin(); } auto format(const Point\u0026amp; p, std::format_context\u0026amp; ctx) const { return std::format_to(ctx.out(), \u0026#34;({}, {})\u0026#34;, p.x, p.y); } }; int main() { Point p{1, 2}; /* 输出 `(1, 2)` */ std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{}\u0026#34;, p) \u0026lt;\u0026lt; std::endl; return 0; } 点击展开查看更多 Range formatting C++23 引入了 range formatting，允许你轻松格式化 vector、map 等容器。在 C++23 中，我们可以使用 std::print 进行输出。\nCPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;version\u0026gt; int main() { const std::set\u0026lt;int\u0026gt; deadbeef{0xDE, 0xAD, 0xBE, 0xEF}; /* C++23 之前 */ bool first = true; std::cout \u0026lt;\u0026lt; \u0026#34;{\u0026#34;; for (const auto\u0026amp; x: deadbeef) { if (!first) std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; else first = false; std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{:#x}\u0026#34;, x); } std::cout \u0026lt;\u0026lt; \u0026#34;}\u0026#34; \u0026lt;\u0026lt; std::endl; /* C++23 之后 */ #ifdef __cpp_lib_format_ranges /* 输出 `{0xad, 0xbe, 0xde, 0xef}` */ std::println(\u0026#34;{::#x}\u0026#34;, deadbeef); #endif return 0; } 点击展开查看更多 第二个 : 之后的格式说明符（#x，带前缀的十六进制）将应用于每个元素。\n带自定义元素类型的 range formatting 将 range formatting 和自定义类型格式化结合起来并不困难。\nCPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;vector\u0026gt; struct Point { int x, y; }; template\u0026lt;\u0026gt; struct std::formatter\u0026lt;Point\u0026gt; { constexpr auto parse(std::format_parse_context\u0026amp; ctx) { return ctx.begin(); } template\u0026lt;typename Out\u0026gt; auto format(const Point\u0026amp; p, std::basic_format_context\u0026lt;Out, char\u0026gt;\u0026amp; ctx) const { return std::format_to(ctx.out(), \u0026#34;({}, {})\u0026#34;, p.x, p.y); } }; int main() { std::vector\u0026lt;Point\u0026gt; ps{{1, 2}, {3, 4}, {5, 6}}; /* 输出 `[(1, 2), (3, 4), (5, 6)]` */ std::println(\u0026#34;{}\u0026#34;, ps); return 0; } 点击展开查看更多 一个小挑战 为什么需要 template\u0026lt;typename Out\u0026gt;？如果将 basic_format_context\u0026lt;Out, char\u0026gt; 替换为 format_context，编译将失败并报错 std::formatter must be specialized for each type being formatted。\nTL;DR: formattable\u0026lt;Point\u0026gt; 要求 format 函数接受的 context 类型不仅仅是 std::format_context。使用 template\u0026lt;typename Out\u0026gt; 可以让它同时适用于两种 context。\n详情 以下是来自 libstdc++ 的实现。\nCPP 折叠 复制 template\u0026lt;typename _Tp, __format::__char _CharT = char\u0026gt; requires same_as\u0026lt;remove_cvref_t\u0026lt;_Tp\u0026gt;, _Tp\u0026gt; \u0026amp;\u0026amp; formattable\u0026lt;_Tp, _CharT\u0026gt; class range_formatter; template\u0026lt;ranges::input_range _Rg, __format::__char _CharT\u0026gt; requires (format_kind\u0026lt;_Rg\u0026gt; != range_format::disabled) \u0026amp;\u0026amp; formattable\u0026lt;ranges::range_reference_t\u0026lt;_Rg\u0026gt;, _CharT\u0026gt; struct formatter\u0026lt;_Rg, _CharT\u0026gt; { private: using _Vt = remove_cvref_t\u0026lt;ranges::range_reference_t\u0026lt;_Rg\u0026gt;\u0026gt;; using _Formatter_under = range_formatter\u0026lt;_Vt, _CharT\u0026gt;; _Formatter_under _M_under; public: /* ... */ }; 点击展开查看更多 formatter\u0026lt;range\u0026gt; 委托给底层的 range_formatter。之前的错误信息表明替换失败了。让我们尝试实例化一个 range_formatter\u0026lt;Point\u0026gt; 看看会发生什么。编译器现在提示 __formattable_with\u0026lt;Point, basic_format_context\u0026lt;_Iter_for_t\u0026lt;char\u0026gt;, char\u0026gt; \u0026gt; 的条件不满足，而这是 formattable\u0026lt;Point\u0026gt; 所要求的。注意：任何以下划线 _ 开头的内容都是与实现相关的。 然而，format_context 是 basic_format_context\u0026lt;_Sink_iter\u0026lt;char\u0026gt;, char\u0026gt; 的别名，它不能满足条件。\nTakeaway：为了兼容性，将 format 函数模板化。\n自定义 range 类型的格式化 如果我们的类满足 input_range 概念，那么 range formatting 应该就可以生效。以下示例模拟了 Python 的 range 类。（为简洁起见，仅展示部分代码。）\nCPP 折叠 复制 class xrange{ public: xrange(int _start, int _stop, int _step = 1); explicit xrange(int _end); class Iterator { public: using difference_type = std::ptrdiff_t; using value_type = int; Iterator\u0026amp; operator ++(); Iterator operator ++(int); value_type operator *() const; }; class Sentinel { public: friend bool operator ==(const Iterator\u0026amp; it, const Sentinel\u0026amp; s); }; Iterator begin() const; Sentinel end() const; }; int main() { int n = 3; /* 输出 `xrange(3) = [0, 1, 2]` */ std::println(\u0026#34;xrange({}) = {}\u0026#34;, n, xrange(n)); return 0; } 点击展开查看更多 完整代码 CPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;stdexcept\u0026gt; class xrange{ private: int m_start, m_stop, m_step; public: xrange(int _start, int _stop, int _step = 1) : m_start(_start), m_stop(_stop), m_step(_step) { if (m_step == 0) throw std::runtime_error(\u0026#34;step must not be zero\u0026#34;); } explicit xrange(int _end) : m_start(0), m_stop(_end), m_step(1) {} class Iterator; class Sentinel; Iterator begin() const { return Iterator{m_start, m_step}; } Sentinel end() const { return Sentinel{m_stop}; } class Iterator { private: int m_value, m_step; friend Sentinel; public: using difference_type = std::ptrdiff_t; using value_type = int; Iterator(int _value, int _step) : m_value(_value), m_step(_step) {} Iterator() = default; Iterator\u0026amp; operator ++() { m_value += m_step; return *this; } Iterator operator ++(int) { auto tmp = *this; ++*this; return tmp; } value_type operator *() const { return m_value; } }; class Sentinel { private: int m_end; public: explicit Sentinel(int _end) : m_end(_end) {} Sentinel() = default; friend bool operator ==(const Iterator\u0026amp; it, const Sentinel\u0026amp; s) { return (it.m_step \u0026gt;= 0 \u0026amp;\u0026amp; it.m_value \u0026gt;= s.m_end) || (it.m_step \u0026lt; 0 \u0026amp;\u0026amp; it.m_value \u0026lt;= s.m_end); } }; }; int main() { int n = 3; /* 输出 `xrange(3) = [0, 1, 2]` */ std::println(\u0026#34;xrange({}) = {}\u0026#34;, n, xrange(n)); return 0; } 点击展开查看更多 Range formatting 修改样式 range_formatter 有三个成员函数可用于修改输出的格式。\nCPP 折叠 复制 constexpr void set_separator( std::basic_string_view\u0026lt;CharT\u0026gt; sep ) noexcept; constexpr void set_brackets( std::basic_string_view\u0026lt;CharT\u0026gt; opening, std::basic_string_view\u0026lt;CharT\u0026gt; closing ) noexcept; constexpr std::formatter\u0026lt;T, CharT\u0026gt;\u0026amp; underlying() noexcept; /* 以及 const 变体 */ 点击展开查看更多 在下面的例子中，我们假设 vector\u0026lt;vector\u0026lt;T\u0026gt;\u0026gt; 代表一个矩阵，应该以不同的方式格式化。（在任何严肃的项目中，都不要为 std::vector 这样的标准库类型特化 std::formatter。）\nCPP 折叠 复制 #include \u0026lt;format\u0026gt; #include \u0026lt;print\u0026gt; #include \u0026lt;vector\u0026gt; template\u0026lt;typename T\u0026gt; requires std::formattable\u0026lt;T, char\u0026gt; struct std::formatter\u0026lt;std::vector\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;\u0026gt; : std::range_formatter\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { constexpr formatter() noexcept { this-\u0026gt;set_separator(\u0026#34;\\n \u0026#34;); this-\u0026gt;underlying().set_separator(\u0026#34; \u0026#34;); this-\u0026gt;underlying().set_brackets(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } }; int main() { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; mat{{1, 2}, {3, 4}}; /* 输出 * ``` * [1 2 * 3 4] * ``` * 而不是 `[[1, 2], [3, 4]]` */ std::println(\u0026#34;{}\u0026#34;, mat); return 0; } 点击展开查看更多 结论 C++23 的范围格式化是对 std::format 功能的一个强大补充，显著减少了处理容器时的代码。要点：\n为了兼容性，始终模板化 format 函数。 如果类型满足 input_range 概念，会自动获得范围格式化功能，无需特化 std::formatter。 使用 range_formatter::set_separator()、set_brackets() 和 underlying() 来修改特定类型的格式化输出。 虽然由于不太友好的错误信息，可能会想为像 vector\u0026lt;MyType\u0026gt; 这样的容器实例特化格式化器，但实现一个正确的 formatter\u0026lt;MyType\u0026gt; 可以更优雅地解决问题。\n此外，与 SFINAE 相比，C++20 概念带来的改进的错误信息让调试变得容易得多。\n","title":"C++23 Range Formatting 实用指南"}],"tags":[{"link":"/zh-cn/tags/c++/","name":"C++","slug":"C++"},{"link":"/zh-cn/tags/programming/","name":"Programming","slug":"Programming"}]}